"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitNamedType = void 0;
const tslib_1 = require("tslib");
const path = require("path");
const graphql_1 = require("graphql");
const utils_1 = require("../utils");
const addExternalResolverImport_1 = require("./addExternalResolverImport");
const visitNamedType = (_a, ctx) => {
    var { namedType, resolverName, belongsToRootObject, location, visitor } = _a, extraParams = tslib_1.__rest(_a, ["namedType", "resolverName", "belongsToRootObject", "location", "visitor"]);
    // Check to see if need to generate resolver files
    const parsedDetails = parseLocationForOutputDir(belongsToRootObject ? [belongsToRootObject] : [], ctx, location);
    if (!parsedDetails) {
        // No `parsedDetails` means the location is NOT whitelisted, ignore.
        return;
    }
    const { moduleName, outputDir } = parsedDetails;
    const normalizedResolverName = normalizeResolverName(moduleName, resolverName, belongsToRootObject);
    const externalResolverImportSyntax = ctx.config.externalResolvers[normalizedResolverName.base];
    // when used with extended object types scenario
    if (externalResolverImportSyntax) {
        // If has external resolver, use it
        (0, addExternalResolverImport_1.addExternalResolverImport)({
            moduleName,
            normalizedResolverName: normalizedResolverName.base,
            configImportSyntax: externalResolverImportSyntax,
        }, ctx);
        return;
    }
    // Generate resolver files based on its type
    const visitorHandlerParamsBase = validateAndPrepareForGraphQLTypeHandler({
        resolverName,
        normalizedResolverName,
        outputDir,
        belongsToRootObject,
        moduleName,
    }, ctx);
    const visitorHandlerParams = Object.assign(Object.assign({}, visitorHandlerParamsBase), extraParams);
    if (visitorHandlerParams.belongsToRootObject) {
        visitor['RootObjectTypeField'](visitorHandlerParams, ctx);
    }
    else {
        if ((0, graphql_1.isObjectType)(namedType)) {
            visitor['ObjectType'](visitorHandlerParams, ctx);
        }
        else if ((0, graphql_1.isUnionType)(namedType)) {
            visitor['UnionType'](visitorHandlerParams, ctx);
        }
        else if ((0, graphql_1.isScalarType)(namedType)) {
            visitor['ScalarType'](visitorHandlerParams, ctx);
        }
        else if ((0, graphql_1.isInterfaceType)(namedType)) {
            visitor['InterfaceType'](visitorHandlerParams, ctx);
        }
    }
};
exports.visitNamedType = visitNamedType;
/**
 * Parse location to see which module it belongs to.
 * Also check against whitelisted and blacklisted to see if need to generate file.
 */
const parseLocationForOutputDir = (nestedDirs, { config: { mode, sourceMap, whitelistedModules, blacklistedModules, baseOutputDir, resolverRelativeTargetDir, }, }, location) => {
    // If mode is "merged", there's only one module:
    //   - always generate a.k.a  it's always whitelisted
    //   - put them together at designated relativeTargetDir
    //   - moduleName='' i.e. no module
    if (mode === 'merged') {
        return {
            outputDir: path.posix.join(baseOutputDir, resolverRelativeTargetDir, ...nestedDirs),
            moduleName: '',
        };
    }
    // 2. mode is "modules", each module is the folder containing the schema files
    // This means one or multiple schema files can add up to one module
    const parsedSource = (0, utils_1.parseLocationForWhitelistedModule)({
        location,
        sourceMap,
        whitelistedModules,
        blacklistedModules,
    });
    return parsedSource
        ? {
            outputDir: path.posix.join(baseOutputDir, parsedSource.moduleName, resolverRelativeTargetDir, ...nestedDirs),
            moduleName: parsedSource.moduleName,
        }
        : undefined;
};
const validateAndPrepareForGraphQLTypeHandler = ({ resolverName, normalizedResolverName, outputDir, belongsToRootObject, moduleName, }, { config, result }) => {
    const fieldFilePath = path.posix.join(outputDir, `${resolverName}.ts`);
    if (result.files[fieldFilePath]) {
        throw new Error(`Unexpected duplication in field filename. Type: ${resolverName}, file: ${fieldFilePath}`);
    }
    // resolverTypeName are generated from typescript-resolvers plugin
    const resolversTypeMetaModule = (0, utils_1.relativeModulePath)(outputDir, config.resolverTypesPath);
    const resolversTypeMeta = belongsToRootObject
        ? {
            typeNamedImport: `${belongsToRootObject}Resolvers`,
            module: resolversTypeMetaModule,
            moduleType: 'file',
            typeString: `${belongsToRootObject}Resolvers['${resolverName}']`,
        }
        : {
            typeNamedImport: `${resolverName}Resolvers`,
            module: resolversTypeMetaModule,
            moduleType: 'file',
            typeString: `${resolverName}Resolvers`,
        };
    return {
        fieldFilePath,
        resolverName,
        belongsToRootObject,
        normalizedResolverName,
        resolversTypeMeta,
        moduleName,
    };
};
/**
 * Function to get format resolver name based on its definition in the schema
 * - Root object type resolver e.g Query.me, Mutation.updateUser
 * - Object type e.g. User, Profile
 *
 * Returns an object with 2 key/value pairs:
 *   - base: resolver name without module. This is used by to match up with config.externalResolvers.
 *   - withModule: resolver name with module. This is used to identify the resolver INTERNAL unique path used in main resolver files.
 */
const normalizeResolverName = (moduleName, name, rootObject) => {
    const baseResolverName = !rootObject ? name : `${rootObject}.${name}`;
    // Note: this is to make sure the resolver name is a valid variable name because we use it in resolvers.generated.ts
    //
    // However, this naive implementation means there could be a duplicated variable name if a mix of kebab-case and snake_case is used.
    // e.g. `user-by-account-name` and `user_by_account_name` will both be normalized to `user_by_account_name`
    //
    // If users report this issue. We can try another approach.
    // I'm banking my slim hope in humanity that no codebase is so chaotic that it uses both kebab-case and snake_case.
    const variableSafeModuleName = moduleName.replace('-', '_');
    return {
        base: baseResolverName,
        withModule: `${variableSafeModuleName}.${baseResolverName}`,
    };
};
//# sourceMappingURL=visitNamedType.js.map