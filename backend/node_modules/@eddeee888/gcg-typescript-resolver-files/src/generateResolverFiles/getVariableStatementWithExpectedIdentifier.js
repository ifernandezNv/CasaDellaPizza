"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVariableStatementWithExpectedIdentifier = void 0;
const getVariableStatementWithExpectedIdentifier = (sourceFile, resolverFile) => {
    var _a, _b;
    let isExported = false;
    const variableStatementWithExpectedIdentifier = sourceFile.getVariableStatement((statement) => {
        let hasExpectedIdentifier = false;
        statement
            .getDeclarationList()
            .getDeclarations()
            .forEach((declarationNode) => {
            if (declarationNode.getName() === resolverFile.mainImportIdentifier) {
                hasExpectedIdentifier = true;
                if (statement.isExported()) {
                    isExported = true;
                }
            }
        });
        return hasExpectedIdentifier;
    });
    /**
     * If we found the variable statement replace its type with the expected resolver type string
     *
     * This is because we change the type of the resolver in some cases:
     * 1. When `extend type <Object>` is used, we might change its original type to the picked version
     *    e.g. `Book` might become `Pick<Book, 'title' | 'author'>`
     */
    if (variableStatementWithExpectedIdentifier &&
        resolverFile.meta.resolverTypeString) {
        (_b = (_a = variableStatementWithExpectedIdentifier
            .getDeclarationList()
            .getDeclarations()[0]) === null || _a === void 0 ? void 0 : _a.getTypeNode()) === null || _b === void 0 ? void 0 : _b.replaceWithText(resolverFile.meta.resolverTypeString);
    }
    return {
        variableStatement: variableStatementWithExpectedIdentifier,
        isExported,
    };
};
exports.getVariableStatementWithExpectedIdentifier = getVariableStatementWithExpectedIdentifier;
//# sourceMappingURL=getVariableStatementWithExpectedIdentifier.js.map